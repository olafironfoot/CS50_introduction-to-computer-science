{"changed":true,"filter":false,"title":"speller.c","tooltip":"/speller/speller.c","value":"/**\n * Implements a spell-checker.\n */\n\n#include <ctype.h>\n#include <stdio.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n\n#include \"dictionary.h\"\n#undef calculate\n#undef getrusage\n\n// default dictionary\n#define DICTIONARY \"dictionaries/large\"\n\n// prototype\ndouble calculate(const struct rusage *b, const struct rusage *a);\n\nint main(int argc, char *argv[])\n{\n    // check for correct number of args\n    if (argc != 2 && argc != 3)\n    {\n        printf(\"Usage: speller [dictionary] text\\n\");\n        return 1;\n    }\n\n    // structs for timing data\n    struct rusage before, after;\n\n    // benchmarks\n    double time_load = 0.0, time_check = 0.0, time_size = 0.0, time_unload = 0.0;\n\n    // determine dictionary to use\n    char* dictionary = (argc == 3) ? argv[1] : DICTIONARY;\n\n    // load dictionary\n    getrusage(RUSAGE_SELF, &before);\n    bool loaded = load(dictionary);\n    getrusage(RUSAGE_SELF, &after);\n\n    // abort if dictionary not loaded\n    if (!loaded)\n    {\n        printf(\"Could not load %s.\\n\", dictionary);\n        return 1;\n    }\n\n    // calculate time to load dictionary\n    time_load = calculate(&before, &after);\n\n    // try to open text\n    char *text = (argc == 3) ? argv[2] : argv[1];\n    FILE *fp = fopen(text, \"r\");\n    if (fp == NULL)\n    {\n        printf(\"Could not open %s.\\n\", text);\n        unload();\n        return 1;\n    }\n\n    // prepare to report misspellings\n    printf(\"\\nMISSPELLED WORDS\\n\\n\");\n\n    // prepare to spell-check\n    int index = 0, misspellings = 0, words = 0;\n    char word[LENGTH+1];\n\n    // spell-check each word in text\n    for (int c = fgetc(fp); c != EOF; c = fgetc(fp))\n    {\n        // allow only alphabetical characters and apostrophes\n        if (isalpha(c) || (c == '\\'' && index > 0))\n        {\n            // append character to word\n            word[index] = c;\n            index++;\n\n            // ignore alphabetical strings too long to be words\n            if (index > LENGTH)\n            {\n                // consume remainder of alphabetical string\n                while ((c = fgetc(fp)) != EOF && isalpha(c));\n\n                // prepare for new word\n                index = 0;\n            }\n        }\n\n        // ignore words with numbers (like MS Word can)\n        else if (isdigit(c))\n        {\n            // consume remainder of alphanumeric string\n            while ((c = fgetc(fp)) != EOF && isalnum(c));\n\n            // prepare for new word\n            index = 0;\n        }\n\n        // we must have found a whole word\n        else if (index > 0)\n        {\n            // terminate current word\n            word[index] = '\\0';\n\n            // update counter\n            words++;\n\n            // check word's spelling\n            getrusage(RUSAGE_SELF, &before);\n            bool misspelled = !check(word);\n            getrusage(RUSAGE_SELF, &after);\n\n            // update benchmark\n            time_check += calculate(&before, &after);\n\n            // print word if misspelled\n            if (misspelled)\n            {\n                printf(\"%s\\n\", word);\n                misspellings++;\n            }\n\n            // prepare for next word\n            index = 0;\n        }\n    }\n\n    // check whether there was an error\n    if (ferror(fp))\n    {\n        fclose(fp);\n        printf(\"Error reading %s.\\n\", text);\n        unload();\n        return 1;\n    }\n\n    // close text\n    fclose(fp);\n\n    // determine dictionary's size\n    getrusage(RUSAGE_SELF, &before);\n    unsigned int n = size();\n    getrusage(RUSAGE_SELF, &after);\n\n    // calculate time to determine dictionary's size\n    time_size = calculate(&before, &after);\n\n    // unload dictionary\n    getrusage(RUSAGE_SELF, &before);\n    bool unloaded = unload();\n    getrusage(RUSAGE_SELF, &after);\n\n    // abort if dictionary not unloaded\n    if (!unloaded)\n    {\n        printf(\"Could not unload %s.\\n\", dictionary);\n        return 1;\n    }\n\n    // calculate time to unload dictionary\n    time_unload = calculate(&before, &after);\n\n    // report benchmarks\n    printf(\"\\nWORDS MISSPELLED:     %d\\n\", misspellings);\n    printf(\"WORDS IN DICTIONARY:  %d\\n\", n);\n    printf(\"WORDS IN TEXT:        %d\\n\", words);\n    printf(\"TIME IN load:         %.2f\\n\", time_load);\n    printf(\"TIME IN check:        %.2f\\n\", time_check);\n    printf(\"TIME IN size:         %.2f\\n\", time_size);\n    printf(\"TIME IN unload:       %.2f\\n\", time_unload);\n    printf(\"TIME IN TOTAL:        %.2f\\n\\n\", \n     time_load + time_check + time_size + time_unload);\n\n    // that's all folks\n    return 0;\n}\n\n/**\n * Returns number of seconds between b and a.\n */\ndouble calculate(const struct rusage *b, const struct rusage *a)\n{\n    if (b == NULL || a == NULL)\n    {\n        return 0.0;\n    }\n    else\n    {\n        return ((((a->ru_utime.tv_sec * 1000000 + a->ru_utime.tv_usec) -\n                 (b->ru_utime.tv_sec * 1000000 + b->ru_utime.tv_usec)) +\n                ((a->ru_stime.tv_sec * 1000000 + a->ru_stime.tv_usec) -\n                 (b->ru_stime.tv_sec * 1000000 + b->ru_stime.tv_usec)))\n                / 1000000.0);\n    }\n}\n","undoManager":{"mark":-2,"position":1,"stack":[[{"start":{"row":27,"column":0},"end":{"row":27,"column":1},"action":"insert","lines":["ยก"],"id":2}],[{"start":{"row":27,"column":0},"end":{"row":27,"column":1},"action":"remove","lines":["ยก"],"id":3}]]},"ace":{"folds":[],"scrolltop":274.5,"scrollleft":0,"selection":{"start":{"row":22,"column":31},"end":{"row":22,"column":31},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1475252749000}